import{_ as e,c as s,d as n,o as i}from"./app-D0nt0rSp.js";const l={};function t(p,a){return i(),s("div",null,a[0]||(a[0]=[n(`<h1 id="uniswap" tabindex="-1"><a class="header-anchor" href="#uniswap"><span>Uniswap</span></a></h1><h2 id="uniswap中间路由实现原理" tabindex="-1"><a class="header-anchor" href="#uniswap中间路由实现原理"><span>Uniswap中间路由实现原理</span></a></h2><p>在去中心化交易所（DEX）Uniswap中，&quot;最佳匹配路径&quot;（Best Route Matching）或“中间路由”是指通过不同的交易对（token pairs）找到最佳的路径，以在不同的资产间进行交换。Uniswap允许通过多个交易对之间的组合来优化交易的价格和滑点，寻找最优路径时的实现涉及到路由算法。下面是Uniswap路径优化的实现原理：</p><h3 id="_1-理解-uniswap-的池和路径" tabindex="-1"><a class="header-anchor" href="#_1-理解-uniswap-的池和路径"><span>1. 理解 Uniswap 的池和路径</span></a></h3><p>Uniswap的交易主要通过**流动性池（liquidity pools）**进行，每个池对应两个代币（token pair）。例如，ETH/DAI 流动性池允许用户在 ETH 和 DAI 之间进行兑换。Uniswap v2/v3 支持在多个流动性池之间进行跨池交换，即用户可以通过中间代币路由将 Token A 转换为 Token B，而不是直接通过单一交易对。 例如，要将 Token A 兑换为 Token B，可能有多个路径：</p><ul><li>直接路径： Token A -&gt; Token B</li><li>间接路径： Token A -&gt; Token C -&gt; Token B</li></ul><p>Uniswap的任务是找到一个最优路径，使得交易者在兑换 Token A 到 Token B 时，能够以最优的汇率（最低滑点、最低交易费用）完成交易。</p><h3 id="_2-路径优化的挑战" tabindex="-1"><a class="header-anchor" href="#_2-路径优化的挑战"><span>2. 路径优化的挑战</span></a></h3><p>Uniswap路径优化的核心挑战在于：</p><ul><li>价格波动和滑点：不同的交易路径可能会因为流动性不同而导致不同的价格滑点。</li><li>流动性分布：每个交易池的流动性不同，可能导致某些路径的执行效率较差。</li><li>交易费用：不同的路径可能涉及不同数量的交易对，更多的交易对可能导致更高的交易费用。</li><li>Gas费用：路径越复杂，智能合约执行的复杂度越高，gas费用可能越高。</li></ul><h3 id="_3-uniswap-路径匹配的原理" tabindex="-1"><a class="header-anchor" href="#_3-uniswap-路径匹配的原理"><span>3. Uniswap 路径匹配的原理</span></a></h3><p>Uniswap 通过一种称为路由算法的技术来找到最佳路径，该算法通常基于图的最短路径或最优路径算法。具体过程如下：</p><h4 id="_3-1-构建流动性池的图模型" tabindex="-1"><a class="header-anchor" href="#_3-1-构建流动性池的图模型"><span>3.1 构建流动性池的图模型</span></a></h4><p>Uniswap的流动性池可以被表示为一个加权图（weighted graph），图中的每个节点代表一个代币，而每条边代表两个代币之间的流动性池。边的权重可以根据当前的汇率（包括滑点和交易费）来计算。 例如，假设有3个代币 A, B, 和 C，则 A/B 和 B/C 可能形成一个交易路径。图模型可以如下表示：</p><div class="language-css line-numbers-mode" data-highlighter="prismjs" data-ext="css" data-title="css"><pre><code><span class="line">A -- B</span>
<span class="line"> \\  /</span>
<span class="line">  C</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>权重表示交易代价（或汇率、滑点等）。</p><h4 id="_3-2-计算每条路径的代价" tabindex="-1"><a class="header-anchor" href="#_3-2-计算每条路径的代价"><span>3.2 计算每条路径的代价</span></a></h4><p>为了找到最优的路径，Uniswap会计算每一条路径的代价。代价的计算不仅考虑汇率，还包括滑点、交易费用和gas成本。具体地，Uniswap的路由器会尝试模拟不同的交易路径并计算每一条路径上的最终输出。 路径代价通常以最少的代币损耗为目标，也就是找到能让用户得到最多 Token B 的路径。</p><h4 id="_3-3-dijkstra-或-bellman-ford-最短路径算法" tabindex="-1"><a class="header-anchor" href="#_3-3-dijkstra-或-bellman-ford-最短路径算法"><span>3.3 Dijkstra 或 Bellman-Ford 最短路径算法</span></a></h4><p>为了计算多个流动性池之间的最优路径，Uniswap可以使用经典的最短路径算法，比如：</p><ul><li>Dijkstra算法：该算法用于寻找加权图中从源节点（起始代币）到目的节点（目标代币）的最短路径。它适合处理权重为正的图。</li><li>Bellman-Ford算法：该算法可以处理权重为负的场景，但一般不适用于Uniswap，因为权重（交易费用和滑点）通常为正。 这些算法可以有效计算从 Token A 到 Token B 所有可能路径中的最优解，找到交易成本最低的路径。</li></ul><h4 id="_3-4-流动性分布和分批执行" tabindex="-1"><a class="header-anchor" href="#_3-4-流动性分布和分批执行"><span>3.4 流动性分布和分批执行</span></a></h4><p>Uniswap V3 引入了集中流动性（concentrated liquidity），不同的池之间流动性可能分布不均。在这种情况下，Uniswap路由器还会考虑如何在多个池之间分配交易量，找到一种组合路径，使总的交易滑点和成本最小化。 Uniswap 的智能合约可以将交易拆分成多条路径，并通过多个流动性池进行分批执行，以获得更好的价格。例如：</p><ul><li>50%通过 Token A -&gt; Token C -&gt; Token B</li><li>50%通过 Token A -&gt; Token D -&gt; Token B</li></ul><h4 id="_3-5-最终选择最优路径" tabindex="-1"><a class="header-anchor" href="#_3-5-最终选择最优路径"><span>3.5 最终选择最优路径</span></a></h4><p>Uniswap 会模拟多个路径，并根据以下因素做出选择：</p><ul><li>交易汇率：找到给用户最优价格的路径。</li><li>滑点：滑点越低，路径越优。</li><li>交易费用：交易路径越短，费用越低。</li><li>gas费用：gas的开销越低，路径越优。 Uniswap 会权衡这些因素，选择最终的最佳路径。</li></ul><h3 id="_4-动态性和实时计算" tabindex="-1"><a class="header-anchor" href="#_4-动态性和实时计算"><span>4. 动态性和实时计算</span></a></h3><p>Uniswap的最佳路径匹配是动态的，这意味着随着交易进行和流动性变化，路径的最优解也会随时改变。因此，Uniswap的路由器在每次执行交易前都会重新计算最佳路径。这种实时计算确保用户能获得当前市场条件下的最优价格。</p><h3 id="_5-uniswap-v3-中的额外优化" tabindex="-1"><a class="header-anchor" href="#_5-uniswap-v3-中的额外优化"><span>5. Uniswap V3 中的额外优化</span></a></h3><p>Uniswap V3 提供了更灵活的路径选择，包括：</p><ul><li>集中流动性范围：用户可以选择在特定价格范围内提供流动性，这使得路由器在选择路径时可以更精确地匹配最优的流动性池。</li><li>多池分流：Uniswap V3 支持在多个池之间拆分交易，以进一步优化交易效果。</li></ul><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><p>Uniswap的最佳匹配路径实现基于图的最优路径算法，通过构建代币和流动性池的图模型，使用算法计算出最优的交易路径。在考虑交易汇率、滑点、交易费用和gas成本的前提下，Uniswap的路由器动态选择最佳的路径，以确保用户在不同代币间交换时能够得到最优的价格和最小的滑点。这种机制让Uniswap能够在去中心化交易中提供高效的交易体验。</p><h2 id="uniswap中的精度" tabindex="-1"><a class="header-anchor" href="#uniswap中的精度"><span>Uniswap中的精度</span></a></h2><p>在Uniswap等去中心化交易所（DEX）中，代币的数量是以高精度处理的。由于区块链的底层技术通常只支持整数运算，而不同代币有各自的精度（即代币的小数位数），Uniswap 对代币数量的精度处理依赖于以下几方面的设计：</p><h3 id="_1-代币的-decimals-属性" tabindex="-1"><a class="header-anchor" href="#_1-代币的-decimals-属性"><span>1. 代币的 decimals 属性</span></a></h3><p>代币的精度（即小数位数）由代币合约的 decimals 属性决定。decimals 指定了代币最小单位的小数位数。例如：</p><ul><li>比特币的代币精度为8，即一个比特币可以精确到 0.00000001。</li><li>以太坊的代币精度为18，即以太币可以精确到 0.000000000000000001。 在以太坊上，代币的decimals属性通常定义在ERC-20代币合约中。代币合约开发者可以自由选择他们代币的小数位数。</li></ul><h3 id="_2-整数处理代币数量" tabindex="-1"><a class="header-anchor" href="#_2-整数处理代币数量"><span>2. 整数处理代币数量</span></a></h3><p>区块链智能合约的运算仅支持整数操作，因此，Uniswap在合约内部并不直接使用浮点数或小数，而是通过将所有的代币数量都转化为最小单位（整数形式）来处理。 假设一个代币 Token A 的精度为 18，则代币在合约中实际存储的单位是最小单位（称为 wei）。例如：</p><ul><li>1 Token A 在合约中的表示为 1 * 10^18 个最小单位。</li><li>0.5 Token A 在合约中的表示为 0.5 * 10^18 = 500000000000000000 个最小单位。 这意味着在Uniswap的交易中，所有代币数量计算都是基于整数运算，代币的实际数量被放大了 10^decimals 倍，以避免处理小数带来的复杂性和误差。</li></ul><h3 id="_3-价格和滑点的精度" tabindex="-1"><a class="header-anchor" href="#_3-价格和滑点的精度"><span>3. 价格和滑点的精度</span></a></h3><p>Uniswap 的价格公式和交易算法（基于恒定乘积公式：x * y = k，其中 x 和 y 代表池中的两种代币的数量）也基于整数运算。由于使用高精度整数，Uniswap可以在交易中提供精确的价格计算。 例如，Uniswap使用整数来表示代币的汇率。例如，假设 Token A 和 Token B 之间的价格为 1.5 Token B per Token A，在实际计算中，Uniswap 会将其表示为 1 * 10^18 Token A 对应 1.5 * 10^18 Token B（根据代币的精度）。 在计算滑点、手续费时，所有操作也都是基于高精度的整数运算，确保最终交易数量和手续费的计算精确且不出现因小数位数舍入而产生的误差。</p><h3 id="_4-用户界面中的精度处理" tabindex="-1"><a class="header-anchor" href="#_4-用户界面中的精度处理"><span>4. 用户界面中的精度处理</span></a></h3><p>虽然在合约内部，代币的数量都是以整数最小单位处理的，但在用户界面中，为了方便用户理解和使用，前端会根据代币的精度属性（decimals），将合约返回的整数最小单位值还原为正常的浮点数形式，并显示相应的小数位数。例如：</p><ul><li>如果智能合约返回的 Token A 数量为 1000000000000000000，前端会根据 decimals = 18 将其显示为 1 Token A。 用户界面还会根据代币的精度选择合适的显示位数，通常显示4到6位小数，以避免太多小数位数导致用户混淆。</li></ul><h3 id="_5-防止精度问题的设计" tabindex="-1"><a class="header-anchor" href="#_5-防止精度问题的设计"><span>5. 防止精度问题的设计</span></a></h3><p>Uniswap 使用的整数运算方法可以避免很多与浮点数相关的精度问题，如：</p><ul><li>舍入误差：在小数位数多的情况下，舍入可能会导致小数误差。通过整数处理，可以避免舍入带来的精度损失。</li><li>交易金额准确性：智能合约需要在链上执行，因此所有金额和数量必须完全确定，整数操作确保交易金额不受精度误差影响。</li></ul><h3 id="_6-erc-20-标准与-uniswap-精度一致性" tabindex="-1"><a class="header-anchor" href="#_6-erc-20-标准与-uniswap-精度一致性"><span>6. ERC-20 标准与 Uniswap 精度一致性</span></a></h3><p>大多数在Uniswap上交易的代币都遵循ERC-20标准。ERC-20标准中的 decimals 定义了代币的精度，并且代币合约返回的数量是最小单位。例如，当一个用户查看其余额时，返回的通常是代币的最小单位数量。Uniswap也完全依赖ERC-20代币的 decimals 属性来处理精度。 由于Uniswap遵循这些精度标准，因此无论哪个ERC-20代币被添加到Uniswap的流动性池中，它都能按照代币自身的精度规则准确地执行交易计算。</p><h3 id="_7-特殊的-uniswap-v3-精度处理" tabindex="-1"><a class="header-anchor" href="#_7-特殊的-uniswap-v3-精度处理"><span>7. 特殊的 Uniswap V3 精度处理</span></a></h3><p>Uniswap V3 引入了更多复杂的交易机制，如集中流动性（Concentrated Liquidity），这些机制对精度要求更高。在V3中，流动性可以在特定的价格范围内被提供，因此在价格移动过程中，智能合约需要非常高的精度来计算每个价格点上的流动性。为此，Uniswap V3 使用了更高精度的算法（例如Q64.96的定点数格式）来保证在复杂流动性分布下的精确价格计算。</p><h3 id="总结-1" tabindex="-1"><a class="header-anchor" href="#总结-1"><span>总结</span></a></h3><p>Uniswap通过以下方式处理代币数量的精度： 1.代币精度属性（decimals）：每个代币定义了自己的精度。 2.整数运算：所有代币的数量在合约内部都转换为整数最小单位，以避免小数运算中的误差。 3.前端展示小数：前端根据代币的 decimals 属性，将合约中的整数数量转换为用户友好的小数形式。 4.防止精度问题：通过使用高精度整数，Uniswap避免了与浮点数相关的精度丢失和误差。 这种机制确保了Uniswap能够以高精度处理不同代币的交易，尤其是在涉及多种精度不同的代币时，能确保交易的安全性和精确性。</p><h2 id="js如何处理代币精度" tabindex="-1"><a class="header-anchor" href="#js如何处理代币精度"><span>JS如何处理代币精度</span></a></h2><p>在JavaScript中处理Uniswap中的代币精度时，通常会通过将代币数量转换为代币的最小单位（即整数形式），以确保精度的一致性。因为区块链和智能合约只支持整数运算，所有代币的数量在合约层面都是以其最小单位进行处理。 以Uniswap为例，代币通常基于ERC-20标准，每个代币有一个 decimals 属性，表示它有多少位小数。JavaScript在处理这些代币数量时需要做以下几步：</p><h3 id="_1-获取代币的精度信息-decimals" tabindex="-1"><a class="header-anchor" href="#_1-获取代币的精度信息-decimals"><span>1. 获取代币的精度信息 (decimals)</span></a></h3><p>每个代币都有一个 decimals 属性来定义它的小数位数。例如，USDC 的 decimals 是6，这意味着1个USDC可以精确到 0.000001 USDC。 通常通过调用ERC-20代币的合约方法 decimals() 来获取代币的精度。Uniswap中，前端代码会通过 web3.js 或 ethers.js 这样的库与区块链交互。 const tokenContract = new ethers.Contract(tokenAddress, erc20Abi, provider); const decimals = await tokenContract.decimals();</p><h3 id="_2-从用户输入转换为最小单位" tabindex="-1"><a class="header-anchor" href="#_2-从用户输入转换为最小单位"><span>2. 从用户输入转换为最小单位</span></a></h3><p>在Uniswap中，当用户输入代币的数量时，前端会将输入的浮点数（如 1.23）转换为整数的最小单位，方便后续与智能合约进行交互。这个转换过程通常是将输入的值乘以 10^decimals。 举个例子，如果用户输入1.23个代币，且代币的精度是6，那么实际传递给智能合约的数量是： const inputAmount = 1.23; const decimals = 6; const amountInSmallestUnit = ethers.utils.parseUnits(inputAmount.toString(), decimals);</p><p>console.log(amountInSmallestUnit.toString()); // &quot;1230000&quot;</p><p>在这个例子中，1.23 的表示会转换为 1230000，这是以最小单位为单位的整数。</p><h3 id="_3-将最小单位转换为用户友好的格式" tabindex="-1"><a class="header-anchor" href="#_3-将最小单位转换为用户友好的格式"><span>3. 将最小单位转换为用户友好的格式</span></a></h3><p>从区块链读取的代币数量通常是最小单位的整数。为了显示给用户理解的值，需要将最小单位转回为常规的小数形式。 例如，如果从智能合约中读取到的代币数量是 1230000（USDC，decimals = 6），则需要将它转换为 1.23 来显示给用户： const smallestUnitAmount = &quot;1230000&quot;; const decimals = 6; const displayAmount = ethers.utils.formatUnits(smallestUnitAmount, decimals);</p><p>console.log(displayAmount); // &quot;1.23&quot;</p><p>在这个例子中，最小单位的 1230000 转换成了 1.23，这是一种用户友好的表示。</p><h3 id="_4-bignumber-处理" tabindex="-1"><a class="header-anchor" href="#_4-bignumber-处理"><span>4. BigNumber 处理</span></a></h3><p>由于JavaScript的原生浮点数不适合处理大数或高精度的运算，在处理区块链代币数量时，通常使用 BigNumber 类型。ethers.js 和 web3.js 都提供了 BigNumber 类来处理这种情况。 例如： const amount = ethers.utils.parseUnits(&quot;1.23&quot;, 18); // 将 1.23 转换为 18位小数的最小单位表示 console.log(amount.toString()); // 打印以最小单位表示的整数</p><p>使用 BigNumber 避免了由于JavaScript的浮点数运算引发的精度丢失问题。</p><h3 id="_5-交易中的精度处理" tabindex="-1"><a class="header-anchor" href="#_5-交易中的精度处理"><span>5. 交易中的精度处理</span></a></h3><p>当用户在Uniswap上进行代币交易时，前端会将用户输入的浮点数转换为最小单位，之后传递给智能合约。例如： const amountIn = ethers.utils.parseUnits(&quot;1.23&quot;, decimals); // 用户输入的数量（如1.23个代币） const amountOutMin = ethers.utils.parseUnits(&quot;0.95&quot;, decimals); // 预期的最少输出数量</p><p>合约会根据交易路径、价格和滑点计算最终输出的最小单位数量，然后再通过 formatUnits 转换回用户可读的值。</p><h3 id="_6-综合示例" tabindex="-1"><a class="header-anchor" href="#_6-综合示例"><span>6. 综合示例</span></a></h3><p>一个完整的流程如下： 1.获取用户输入的代币数量（如 1.23）。 2.根据代币的 decimals 属性，将输入的数量转换为最小单位。 3.将转换后的数量传递给智能合约进行交易。 4.从智能合约获取结果，将最小单位的结果转回用户友好的表示。 async function swap(tokenAddress, inputAmount, outputMin, userAddress) { // 获取代币合约实例 const tokenContract = new ethers.Contract(tokenAddress, erc20Abi, provider);</p><pre><code>// 获取代币的小数位数
const decimals = await tokenContract.decimals();

// 将用户输入的浮点数转换为最小单位
const amountInSmallestUnit = ethers.utils.parseUnits(inputAmount.toString(), decimals);
const amountOutMinSmallestUnit = ethers.utils.parseUnits(outputMin.toString(), decimals);

// 执行交易...
const tx = await routerContract.swapExactTokensForTokens(
    amountInSmallestUnit,        // 输入的最小单位数量
    amountOutMinSmallestUnit,    // 最少输出的最小单位数量
    [tokenAAddress, tokenBAddress], // 交易路径
    userAddress,                 // 用户地址
    deadline                     // 截止时间
);

// 交易完成后展示给用户的结果
const resultAmountOut = ethers.utils.formatUnits(amountOutFromContract, decimals);
console.log(\`您获得的代币数量为: \${resultAmountOut}\`);
</code></pre><p>}</p><h3 id="_7-处理精度误差" tabindex="-1"><a class="header-anchor" href="#_7-处理精度误差"><span>7. 处理精度误差</span></a></h3><p>由于区块链合约只支持整数运算，确保精度的一致性是至关重要的。通过严格使用整数表示代币数量，并在显示时根据 decimals 属性处理格式化，能够有效避免因浮点数带来的误差问题。</p><h3 id="总结-2" tabindex="-1"><a class="header-anchor" href="#总结-2"><span>总结</span></a></h3><p>在Uniswap的JS代码中处理代币精度的主要步骤包括： 1.获取代币的精度信息 (decimals)。 2.将用户输入的代币数量转换为最小单位的整数形式。 3.与智能合约交互时始终使用最小单位表示代币数量。 4.通过 BigNumber 进行高精度运算，避免浮点数误差。 5.读取智能合约返回的数据后，将最小单位转换回用户友好的格式以显示。 使用 ethers.js 或 web3.js 处理这些精度转换和大数运算可以确保代币数量在区块链上的精度处理准确无误。</p><h2 id="区块链中如何处理精度计算" tabindex="-1"><a class="header-anchor" href="#区块链中如何处理精度计算"><span>区块链中如何处理精度计算</span></a></h2><p>在区块链应用（尤其是处理代币交易、智能合约交互）中，处理代币精度的加减乘除运算时，精度管理非常重要。由于 JavaScript 的浮点数计算存在精度误差，在处理区块链代币时，必须通过使用整数运算（即代币的最小单位）来确保精度，并利用 BigNumber 类等工具来进行大数和高精度的计算。下面介绍如何在区块链代币精度计算中进行加减乘除运算并确保精度。</p><h3 id="_1-为什么需要确保精度" tabindex="-1"><a class="header-anchor" href="#_1-为什么需要确保精度"><span>1. 为什么需要确保精度？</span></a></h3><p>JavaScript 的标准浮点数（Number 类型）基于 IEEE 754 双精度浮点数标准，其运算在处理大数和高精度时会出现精度丢失问题。例如： console.log(0.1 + 0.2); // 输出：0.30000000000000004</p><p>在区块链上，代币数量精度非常高，通常以 18 位小数表示（如以太坊和许多 ERC-20 代币）。为了避免精度问题，通常使用代币的最小单位（整数）表示数值，并使用大数运算（BigNumber）进行计算。</p><h3 id="_2-使用-bignumber-处理精度" tabindex="-1"><a class="header-anchor" href="#_2-使用-bignumber-处理精度"><span>2. 使用 BigNumber 处理精度</span></a></h3><p>BigNumber 是一种用于处理大整数的工具类，能够避免 JavaScript 内置的 Number 类型处理大数和小数时的精度丢失问题。在区块链开发中，常用的库如 ethers.js 和 web3.js 都内置了 BigNumber 类。</p><h4 id="_2-1-ethers-js-中的-bignumber" tabindex="-1"><a class="header-anchor" href="#_2-1-ethers-js-中的-bignumber"><span>2.1 ethers.js 中的 BigNumber</span></a></h4><ul><li>加法：BigNumber.add()</li><li>减法：BigNumber.sub()</li><li>乘法：BigNumber.mul()</li><li>除法：BigNumber.div()</li></ul><h4 id="_2-2-示例-加减乘除运算" tabindex="-1"><a class="header-anchor" href="#_2-2-示例-加减乘除运算"><span>2.2 示例：加减乘除运算</span></a></h4><p>假设有两个代币交易，我们需要进行加减乘除操作： const { ethers } = require(&#39;ethers&#39;);</p><p>// 假设代币的精度为18 const decimals = 18;</p><p>// 将1.23 和 2.34代币转换为最小单位表示 const amountA = ethers.utils.parseUnits(&quot;1.23&quot;, decimals); // 1.23 转换为最小单位 const amountB = ethers.utils.parseUnits(&quot;2.34&quot;, decimals); // 2.34 转换为最小单位</p><p>// 加法运算 const sum = amountA.add(amountB); console.log(ethers.utils.formatUnits(sum, decimals)); // 输出：3.57</p><p>// 减法运算 const difference = amountA.sub(amountB); console.log(ethers.utils.formatUnits(difference, decimals)); // 输出：-1.11</p><p>// 乘法运算 (注意乘法需要额外处理精度问题) const product = amountA.mul(2); // 1.23 * 2 console.log(ethers.utils.formatUnits(product, decimals)); // 输出：2.46</p><p>// 除法运算 const quotient = amountA.div(2); // 1.23 / 2 console.log(ethers.utils.formatUnits(quotient, decimals)); // 输出：0.615</p><h3 id="_3-乘法和除法中的精度处理" tabindex="-1"><a class="header-anchor" href="#_3-乘法和除法中的精度处理"><span>3. 乘法和除法中的精度处理</span></a></h3><p>乘法和除法通常是精度计算中最容易出错的部分，因为在区块链中，代币通常以整数的最小单位表示。在乘除运算时，特别是在涉及代币精度时，必须谨慎处理。</p><h4 id="_3-1-乘法中的精度问题" tabindex="-1"><a class="header-anchor" href="#_3-1-乘法中的精度问题"><span>3.1 乘法中的精度问题</span></a></h4><p>当两个最小单位表示的数相乘时，结果的精度会被放大。为了保持结果的精度，通常需要进行适当的调整，即缩小精度（通常需要除以 10^decimals）。 const amountA = ethers.utils.parseUnits(&quot;1.23&quot;, decimals); // 1.23 的最小单位 const multiplier = ethers.utils.parseUnits(&quot;2&quot;, 0); // 乘以2</p><p>// 直接相乘会放大精度 const product = amountA.mul(multiplier);</p><p>// 为了确保精度，需要在乘法后除以 10^decimals const adjustedProduct = product.div(ethers.BigNumber.from(10).pow(decimals)); console.log(ethers.utils.formatUnits(adjustedProduct, decimals)); // 输出：2.46</p><h4 id="_3-2-除法中的精度问题" tabindex="-1"><a class="header-anchor" href="#_3-2-除法中的精度问题"><span>3.2 除法中的精度问题</span></a></h4><p>除法可能导致结果变为小数。由于区块链上只处理整数运算，我们需要在执行除法时先放大精度，然后再进行整数除法。 const amountA = ethers.utils.parseUnits(&quot;1.23&quot;, decimals); // 1.23 的最小单位 const divisor = ethers.BigNumber.from(2);</p><p>// 为了保持精度，先放大代币数量 const scaledAmount = amountA.mul(ethers.BigNumber.from(10).pow(decimals));</p><p>// 再进行除法 const quotient = scaledAmount.div(divisor).div(ethers.BigNumber.from(10).pow(decimals)); console.log(ethers.utils.formatUnits(quotient, decimals)); // 输出：0.615</p><h3 id="_4-除以非整数" tabindex="-1"><a class="header-anchor" href="#_4-除以非整数"><span>4. 除以非整数</span></a></h3><p>当除以非整数时，例如 1.23 除以 1.5，我们需要在除法前放大精度，然后进行整数除法。 const amountA = ethers.utils.parseUnits(&quot;1.23&quot;, decimals); // 1.23 的最小单位 const divisor = ethers.utils.parseUnits(&quot;1.5&quot;, decimals); // 1.5 的最小单位</p><p>// 放大精度后执行除法 const quotient = amountA.mul(ethers.BigNumber.from(10).pow(decimals)).div(divisor); console.log(ethers.utils.formatUnits(quotient, decimals)); // 输出：0.82</p><h3 id="_5-防止舍入误差" tabindex="-1"><a class="header-anchor" href="#_5-防止舍入误差"><span>5. 防止舍入误差</span></a></h3><p>当结果小数位较多时，JavaScript在处理时可能会进行自动舍入。为确保精度，可以使用 BigNumber 来精确控制小数位数，避免舍入带来的误差。也可以通过 toFixed() 方法在前端进行舍入： const displayAmount = parseFloat(ethers.utils.formatUnits(sum, decimals)).toFixed(2); console.log(displayAmount); // 输出精确到2位小数：3.57</p><h3 id="总结-3" tabindex="-1"><a class="header-anchor" href="#总结-3"><span>总结</span></a></h3><p>为了确保区块链代币精度计算的准确性，以下是推荐的做法： 1.始终使用最小单位进行运算：将代币数量转换为最小单位，避免使用浮点数运算。 2.使用 BigNumber 进行加减乘除运算：避免使用JavaScript内置的浮点数运算，确保处理大数和高精度时不会发生精度丢失。 3.乘法后调整精度：乘法运算后需要调整精度，通常需要除以 10^decimals。 4.除法时先放大精度：为了避免精度丢失，在除法运算前放大精度，然后再进行除法计算。 5.前端展示时确保舍入：在显示给用户时，使用 toFixed() 或其他方法确保舍入小数位数。 通过这些方法，可以确保区块链代币的加减乘除运算在JavaScript环境中的高精度和准确性。</p><h2 id="滑点" tabindex="-1"><a class="header-anchor" href="#滑点"><span>滑点</span></a></h2><p>在 Uniswap 交易中，滑点（Slippage） 是指在交易过程中，由于市场条件的变化，导致最终成交价格与预期价格之间的差异。滑点通常发生在流动性较低的市场或交易量较大的情况下，可能导致交易者获得的代币数量低于预期。</p><h3 id="滑点的原因" tabindex="-1"><a class="header-anchor" href="#滑点的原因"><span>滑点的原因</span></a></h3><p>滑点在 Uniswap 中的产生主要有以下原因：</p><p>1.自动做市商机制</p><p>Uniswap 使用自动化做市商（AMM）模型，每个交易池通过恒定乘积公式（x×y=kx \\times y = kx×y=k）来维持代币价格。这意味着，当一个交易发生时，池中的代币数量变化会导致价格的变动。交易量越大，对池中代币数量的影响就越显著，从而产生滑点。</p><p>2.流动性不足</p><p>在流动性较低的交易池中，每笔交易对价格的影响更大。因此，如果池中的流动性不足，交易将更容易导致滑点。流动性高的池更能承受大额交易，从而减少滑点。</p><p>3.市场波动</p><p>如果市场价格波动较大，尤其是在价格急剧上升或下降的情况下，交易价格可能会显著偏离预期价格。这会增加滑点的可能性。</p><h3 id="滑点的计算方式" tabindex="-1"><a class="header-anchor" href="#滑点的计算方式"><span>滑点的计算方式</span></a></h3><p>在 Uniswap 中，滑点的大小可以通过以下公式计算：滑点=(预期价格−实际价格预期价格)×100%\\text{滑点} = \\left( \\frac{\\text{预期价格} - \\text{实际价格}}{\\text{预期价格}} \\right) \\times 100%滑点=(预期价格预期价格−实际价格​)×100% 其中，预期价格是交易者期望的代币兑换比例，而实际价格是在交易完成时的兑换比例。滑点越高，交易者所获得的代币数量相对期望的就越少。</p><h3 id="滑点示例" tabindex="-1"><a class="header-anchor" href="#滑点示例"><span>滑点示例</span></a></h3><p>假设一个交易者希望将 10 个代币 A 换成代币 B，预期兑换比例为 1 A = 2 B（总共可得 20 个 B）。由于滑点的影响，实际完成交易时，兑换比例可能变为 1 A = 1.8 B，交易者最终只能获得 18 个 B。这种情况下的滑点为：滑点=(2−1.82)×100%=10%\\text{滑点} = \\left( \\frac{2 - 1.8}{2} \\right) \\times 100% = 10%滑点=(22−1.8​)×100%=10%</p><h3 id="uniswap-对滑点的处理方式" tabindex="-1"><a class="header-anchor" href="#uniswap-对滑点的处理方式"><span>Uniswap 对滑点的处理方式</span></a></h3><p>1.滑点容忍度</p><p>Uniswap 允许用户在发起交易时设定一个“滑点容忍度”，即用户可以接受的最大滑点百分比。如果实际滑点超过这个设定值，交易将自动撤销。这可以防止由于滑点过大而导致的高额损失。</p><p>2.路径优化</p><p>Uniswap V3 引入了集中流动性和中间路由（Multi-Hops），可以在多个流动性池中寻找更优路径，从而减少滑点。 3.实时价格更新</p><p>由于区块链的交易确认机制可能导致价格延迟变化，Uniswap 的智能合约在执行交易时会尽量确保预估的价格变化范围不超过用户设定的滑点容忍度。</p><h3 id="总结-4" tabindex="-1"><a class="header-anchor" href="#总结-4"><span>总结</span></a></h3><p>滑点是 Uniswap 和其他去中心化交易所交易中不可避免的现象，尤其在流动性不足或交易量较大时更为明显。通过滑点容忍度的设定、路径优化等措施，Uniswap 尽可能降低滑点带来的不利影响，帮助用户实现更优的交易体验。</p><h2 id="工厂合约和路由合约的作用" tabindex="-1"><a class="header-anchor" href="#工厂合约和路由合约的作用"><span>工厂合约和路由合约的作用</span></a></h2><p>在 Uniswap 中，**工厂合约（Factory Contract）和路由合约（Router Contract）**是核心组件，分别负责流动性池的创建和交易的执行。它们的具体作用如下：</p><ol><li>工厂合约（Factory Contract）</li></ol><p>工厂合约是 Uniswap 协议中的主要管理合约，用于创建和管理流动性池。</p><h4 id="作用" tabindex="-1"><a class="header-anchor" href="#作用"><span>作用</span></a></h4><ul><li>创建流动性池：工厂合约负责新流动性池的创建。每当用户想要在 Uniswap 上创建一个新的代币对池（如 ETH/DAI），工厂合约会生成并部署一个对应的流动性池合约。</li><li>记录和存储池的地址：每一个流动性池都由工厂合约创建并记录，工厂合约会将代币对与池的地址关联起来。这样，用户可以通过工厂合约找到任意两种代币的流动性池地址。</li><li>防止重复池：工厂合约确保每个代币对只能对应一个流动性池，防止重复创建。用户查询工厂合约即可找到指定代币对的唯一池地址。</li><li>统一管理和参数设置：工厂合约可以在需要时对流动性池进行统一设置和管理，如设定协议参数、升级某些功能（在 V3 中协议费率的调整由工厂合约控制）。</li></ul><h4 id="工作流程" tabindex="-1"><a class="header-anchor" href="#工作流程"><span>工作流程</span></a></h4><p>1.用户调用工厂合约来创建一个新的代币对池，提供代币对的地址。 2.工厂合约检查池是否已存在，若不存在，则部署一个新的流动性池合约。 3.生成的流动性池地址会存储在工厂合约中供后续查询。</p><h4 id="版本差异" tabindex="-1"><a class="header-anchor" href="#版本差异"><span>版本差异</span></a></h4><p>在 Uniswap V2 和 V3 中，工厂合约的基本职责相同，但 V3 引入了集中流动性机制，允许用户在指定价格区间内提供流动性，使得工厂合约的设计更灵活复杂。</p><ol start="2"><li>路由合约（Router Contract）</li></ol><p>路由合约主要负责执行交易，简化用户交互，使得用户可以方便地完成代币兑换和流动性管理。</p><h4 id="作用-1" tabindex="-1"><a class="header-anchor" href="#作用-1"><span>作用</span></a></h4><ul><li>代币兑换（交易路由）：路由合约帮助用户在多个流动性池之间找到最佳路径，以最优价格完成代币兑换。它会根据工厂合约中记录的池地址自动找到路径并执行兑换。</li><li>处理多跳路径：在 Uniswap 中，如果两个代币之间没有直接的流动性池，路由合约可以将交易拆分成多跳（多步）路径，以通过其他池实现最终的兑换。比如要将代币 A 换成代币 C，可以通过 A→B→C 的路径完成。</li><li>流动性管理：路由合约允许用户方便地在不同池中添加或移除流动性。用户可以在单一交易中完成两种代币的流动性添加或移除操作，简化操作步骤。</li><li>滑点保护：在交易中，路由合约允许用户设置滑点容忍度，确保如果兑换价格变动超过指定容忍度，交易会自动撤销，从而避免因价格波动导致的亏损。</li></ul><h4 id="工作流程-1" tabindex="-1"><a class="header-anchor" href="#工作流程-1"><span>工作流程</span></a></h4><p>1.用户调用路由合约发起交易，指定目标代币、金额、滑点容忍度等参数。 2.路由合约通过工厂合约找到所需的流动性池地址。 3.路由合约选择最佳路径，并自动调用相关的流动性池合约完成兑换操作。 4.如果用户发起的是流动性添加或移除操作，路由合约会简化操作过程，以便在单笔交易中完成多个代币的管理。</p><h3 id="总结-5" tabindex="-1"><a class="header-anchor" href="#总结-5"><span>总结</span></a></h3><ul><li>工厂合约：负责创建和记录所有的流动性池，每个代币对只能有一个对应的流动性池。</li><li>路由合约：用于处理用户交易，负责寻找最佳路径、执行代币兑换、流动性管理等。</li></ul><p>通过工厂合约和路由合约的协作，Uniswap 能够实现自动化流动性管理和便捷的代币兑换，为用户提供简洁高效的去中心化交易体验。</p>`,157)]))}const h=e(l,[["render",t],["__file","uniswap.html.vue"]]),d=JSON.parse('{"path":"/zh/web3/uniswap.html","title":"Uniswap","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"Uniswap中间路由实现原理","slug":"uniswap中间路由实现原理","link":"#uniswap中间路由实现原理","children":[{"level":3,"title":"1. 理解 Uniswap 的池和路径","slug":"_1-理解-uniswap-的池和路径","link":"#_1-理解-uniswap-的池和路径","children":[]},{"level":3,"title":"2. 路径优化的挑战","slug":"_2-路径优化的挑战","link":"#_2-路径优化的挑战","children":[]},{"level":3,"title":"3. Uniswap 路径匹配的原理","slug":"_3-uniswap-路径匹配的原理","link":"#_3-uniswap-路径匹配的原理","children":[]},{"level":3,"title":"4. 动态性和实时计算","slug":"_4-动态性和实时计算","link":"#_4-动态性和实时计算","children":[]},{"level":3,"title":"5. Uniswap V3 中的额外优化","slug":"_5-uniswap-v3-中的额外优化","link":"#_5-uniswap-v3-中的额外优化","children":[]},{"level":3,"title":"总结","slug":"总结","link":"#总结","children":[]}]},{"level":2,"title":"Uniswap中的精度","slug":"uniswap中的精度","link":"#uniswap中的精度","children":[{"level":3,"title":"1. 代币的 decimals 属性","slug":"_1-代币的-decimals-属性","link":"#_1-代币的-decimals-属性","children":[]},{"level":3,"title":"2. 整数处理代币数量","slug":"_2-整数处理代币数量","link":"#_2-整数处理代币数量","children":[]},{"level":3,"title":"3. 价格和滑点的精度","slug":"_3-价格和滑点的精度","link":"#_3-价格和滑点的精度","children":[]},{"level":3,"title":"4. 用户界面中的精度处理","slug":"_4-用户界面中的精度处理","link":"#_4-用户界面中的精度处理","children":[]},{"level":3,"title":"5. 防止精度问题的设计","slug":"_5-防止精度问题的设计","link":"#_5-防止精度问题的设计","children":[]},{"level":3,"title":"6. ERC-20 标准与 Uniswap 精度一致性","slug":"_6-erc-20-标准与-uniswap-精度一致性","link":"#_6-erc-20-标准与-uniswap-精度一致性","children":[]},{"level":3,"title":"7. 特殊的 Uniswap V3 精度处理","slug":"_7-特殊的-uniswap-v3-精度处理","link":"#_7-特殊的-uniswap-v3-精度处理","children":[]},{"level":3,"title":"总结","slug":"总结-1","link":"#总结-1","children":[]}]},{"level":2,"title":"JS如何处理代币精度","slug":"js如何处理代币精度","link":"#js如何处理代币精度","children":[{"level":3,"title":"1. 获取代币的精度信息 (decimals)","slug":"_1-获取代币的精度信息-decimals","link":"#_1-获取代币的精度信息-decimals","children":[]},{"level":3,"title":"2. 从用户输入转换为最小单位","slug":"_2-从用户输入转换为最小单位","link":"#_2-从用户输入转换为最小单位","children":[]},{"level":3,"title":"3. 将最小单位转换为用户友好的格式","slug":"_3-将最小单位转换为用户友好的格式","link":"#_3-将最小单位转换为用户友好的格式","children":[]},{"level":3,"title":"4. BigNumber 处理","slug":"_4-bignumber-处理","link":"#_4-bignumber-处理","children":[]},{"level":3,"title":"5. 交易中的精度处理","slug":"_5-交易中的精度处理","link":"#_5-交易中的精度处理","children":[]},{"level":3,"title":"6. 综合示例","slug":"_6-综合示例","link":"#_6-综合示例","children":[]},{"level":3,"title":"7. 处理精度误差","slug":"_7-处理精度误差","link":"#_7-处理精度误差","children":[]},{"level":3,"title":"总结","slug":"总结-2","link":"#总结-2","children":[]}]},{"level":2,"title":"区块链中如何处理精度计算","slug":"区块链中如何处理精度计算","link":"#区块链中如何处理精度计算","children":[{"level":3,"title":"1. 为什么需要确保精度？","slug":"_1-为什么需要确保精度","link":"#_1-为什么需要确保精度","children":[]},{"level":3,"title":"2. 使用 BigNumber 处理精度","slug":"_2-使用-bignumber-处理精度","link":"#_2-使用-bignumber-处理精度","children":[]},{"level":3,"title":"3. 乘法和除法中的精度处理","slug":"_3-乘法和除法中的精度处理","link":"#_3-乘法和除法中的精度处理","children":[]},{"level":3,"title":"4. 除以非整数","slug":"_4-除以非整数","link":"#_4-除以非整数","children":[]},{"level":3,"title":"5. 防止舍入误差","slug":"_5-防止舍入误差","link":"#_5-防止舍入误差","children":[]},{"level":3,"title":"总结","slug":"总结-3","link":"#总结-3","children":[]}]},{"level":2,"title":"滑点","slug":"滑点","link":"#滑点","children":[{"level":3,"title":"滑点的原因","slug":"滑点的原因","link":"#滑点的原因","children":[]},{"level":3,"title":"滑点的计算方式","slug":"滑点的计算方式","link":"#滑点的计算方式","children":[]},{"level":3,"title":"滑点示例","slug":"滑点示例","link":"#滑点示例","children":[]},{"level":3,"title":"Uniswap 对滑点的处理方式","slug":"uniswap-对滑点的处理方式","link":"#uniswap-对滑点的处理方式","children":[]},{"level":3,"title":"总结","slug":"总结-4","link":"#总结-4","children":[]}]},{"level":2,"title":"工厂合约和路由合约的作用","slug":"工厂合约和路由合约的作用","link":"#工厂合约和路由合约的作用","children":[{"level":3,"title":"总结","slug":"总结-5","link":"#总结-5","children":[]}]}],"git":{"updatedTime":1736862884000,"contributors":[{"name":"zhan_zhang","username":"zhan_zhang","email":"18311292602@163.com","commits":1,"url":"https://github.com/zhan_zhang"}]},"filePathRelative":"zh/web3/uniswap.md"}');export{h as comp,d as data};
